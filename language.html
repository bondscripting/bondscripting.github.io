<!DOCTYPE html>
<html>
<head>
<title>Bond Programming Language</title>
<link rel="stylesheet" type="text/css" href="css/bond.css">
</head>

<body>
<div class="page">

<div class="header">
<img class="headlogo" src="img/bond_logo_90x124.png" alt="Bond Logo">
<p class="prodid">Bond</p>
</div>

<ul class="navbar">
<li class="navbutton"><a href="index.html">Home</a></li>
<li class="navbutton"><a href="documentation.html">Documentation</a></li>
<li class="navbutton"><a href="download.html">Download</a></li>
<li class="navbutton"><a href="license.html">License</a></li>
</ul>

<div class="content">
<h2 id="language">The Bond Language</h2>
<p>When Bond was created, the goal was not to invent yet another language; it was more of an endeavour to create a minimalistic runtime environment for a bytecode interpreted language. So, where possible, Bond borrowed its syntax and semantics from C. This document begins by covering some notable differences that exist between Bond and C that exist in the spirit of keeping things clean and simple. Then the document moves on to cover the Bond language in detail.</p>

<ul class="toc">
<li class="toc_h2"><a href="#differences_with_c">Notable Differences With C</a></li>
<li class="toc_h3"><a href="#diff_no_preprocessor">No preprocessor</a></li>
<li class="toc_h3"><a href="#diff_no_headers">No header files or forward declarations</a></li>
<li class="toc_h3"><a href="#diff_include">Include directives</a></li>
<li class="toc_h3"><a href="#diff_ambiguities">Ambiguities in the grammar</a></li>
<li class="toc_h3"><a href="#diff_type_declarations">Type declarations</a></li>
<li class="toc_h3"><a href="#diff_primitive_names">Primitive type names</a></li>
<li class="toc_h3"><a href="#diff_fixed_width">Numeric types have a fixed width</a></li>
<li class="toc_h3"><a href="#diff_no_function_pointers">No function pointers</a></li>
<li class="toc_h3"><a href="#diff_no_variadic_functions">No variadic functions</a></li>
<li class="toc_h3"><a href="#diff_namespaces">Namespaces</a></li>
<li class="toc_h3"><a href="#diff_member_functions">Structs can have member functions</a></li>
<li class="toc_h3"><a href="#diff_no_globals">No global or static variables</a></li>
<li class="toc_h3"><a href="#diff_native_blocks">Native blocks</a></li>
<li class="toc_h2"><a href="#language_ref">Language Reference</a></li>
<li class="toc_h3"><a href="#elements">Basics of Bond</a></li>
<li class="toc_h4"><a href="#None">Structure of a Program</a></li>
<li class="toc_h4"><a href="#identifiers">Identifiers</a></li>
<li class="toc_h4"><a href="#keywords">Keywords</a></li>
<li class="toc_h4"><a href="#primitive_types">Primitive Types</a></li>
<li class="toc_h5"><a href="#boolean_type">Boolean Type</a></li>
<li class="toc_h5"><a href="#integer_types">Integer Types</a></li>
<li class="toc_h5"><a href="#floating_point_types">Floating-Point Types</a></li>
<li class="toc_h4"><a href="#literal_constants">Literal Constants</a></li>
<li class="toc_h5"><a href="#bool_constants">Boolean Constants</a></li>
<li class="toc_h5"><a href="#integer_constants">Integer Constants</a></li>
<li class="toc_h5"><a href="#floating_point_constants">Floating-Point Constants</a></li>
<li class="toc_h5"><a href="#character_constants">Character Constants</a></li>
<li class="toc_h5"><a href="#string_literals">String Literals</a></li>
<li class="toc_h4"><a href="#variables">Variables</a></li>
<li class="toc_h4"><a href="#punctuation">Operators</a></li>
<li class="toc_h3"><a href="#statements">Statements</a></li>
<li class="toc_h3"><a href="#functions">Functions</a></li>
<li class="toc_h3"><a href="#data_types">Data Types</a></li>
<li class="toc_h4"><a href="#enum_types">Enumerated Types</a></li>
<li class="toc_h4"><a href="#array_types">Array Types</a></li>
<li class="toc_h4"><a href="#struct_types">Structure Types</a></li>
<li class="toc_h4"><a href="#pointer_types">Pointer Types</a></li>
<li class="toc_h3"><a href="#namespaces">Namespaces</a></li>
<li class="toc_h3"><a href="#native_blocks">Native Blocks</a></li>
</ul>

<h2 id="differences_with_c">Notable Differences With C</h2>

<h4 id="diff_no_preprocessor">No preprocessor</h4>
<p>There is no preprocessor, so there are no macros or other mechanisms to manipulate the source code before it is scanned by the compiler.</p>

<h4 id="diff_no_headers">No header files or forward declarations</h4>
<p>All code is placed in .bond files with no need for separate header files. Header files are not needed since type, function and constant declarations do not need to occur before they are referenced in source code; the compiler will resolve those references during semantic analysis after all files have been parsed. This important difference with C also means that structs do not need to be forward declared and functions do not need separate declarations and definitions.</p>

<h4 id="diff_include">Include directives</h4>
<p>Despite the lack of header files, the Bond language supports include directives so that the compiler may be informed about where referenced code is defined so that it may be scanned and parsed prior to semantic analysis. In contrast to C's include directive, Bond's is a compiler directive, not a preprocessor directive. The text of the included file is not substituted in place into the including file. Instead, the referenced file is added to the list of files to be scanned by the compiler if it is not already in the list. If files are multiply or circularly included, the compiler will only scan the included file once. The syntax is as follows. Note that <span class="token">include</span> is a reserved keyword.</p>

<pre class="code">include &quot;file/to/include.bond&quot;;</pre>

<h4 id="diff_ambiguities">Ambiguities in the grammar</h4>
<p>C's grammar is ambiguous and Bond inherited those ambiguities. Some statements in C can be parsed in more than one way, such as the following:</p>

<pre class="code">A * B;</pre>

<p>This line of code can be parsed as the declarative statement: <span class="token">B</span> is a pointer to type <span class="token">A</span>. Or it can be parsed as the expression statement: the value of variable <span class="token">A</span> times the value of variable <span class="token">B</span>. C compilers resolve the ambiguity using forward declarations and by giving the parser access to the symbol table so that it can look up whether <span class="token">A</span> is a type. This approach introduces a burden on the programmer to add forward declarations to the source code and pushes elements of semantic analysis (i.e. maintenance of the symbol table) into the parser.</p>

<p>Fortunately, such ambiguities result in statements with no effect when parsed as expression statements, so it is not necessary to support such statements. Bond's approach to resolving the ambiguity is to favour parsing statements as declarative statements whenever possible. If it turns out that <span class="token">A</span> is not a type, the semantic analyzer will raise an error to that effect during a later stage of compilation.</p>

<p>In hindsight, it may have been worth considering eliminating such ambiguities by modifying the syntax for declarative statements.</p>

<p>For clarity and to avoid other possible ambiguities, the syntax for casting and the sizeof operator were both slightly modified. The syntax for casting is:</p>

<pre class="code">cast&lt;type&gt;(expression)</pre>

<p>The sizeof operator comes in two forms: one for types and one for expressions:</p>

<pre class="code">sizeof&lt;type&gt;
sizeof expression</pre>

<p>The expression in the second form can optionally be wrapped in parentheses as is the case in C.</p>

<h4 id="diff_type_declarations">Type declarations</h4>
<p>To simplify reading and parsing type declarations, all elements pertaining to type declarations (e.g. type names, <span class="token">[]</span>, <span class="token">*</span>, <span class="token">const</span>) appear prior to variable names. The most obvious effect of this change is with array declarations, but there are some other subtleties as well.</p>

<pre class="code">int[3][5] array; // C equivalent is: int array[3][5];
int[3] a, b;     // Both a and b are of type int[3].
int* a, b;       // Both a and b are of type int*. In C, a is int* and b is int.</pre>

<h4 id="diff_primitive_names">Primitive type names</h4>
<p>All primitive type names consist of a single reserved keyword. Where C has the type <span class="token">unsigned int</span>, Bond has <span class="token">uint</span>.</p>

<h4 id="diff_fixed_width">Numeric types have a fixed width</h4>
<p>The types <span class="token">char</span>, <span class="token">short</span>, <span class="token">int</span> and <span class="token">long</span> (as well as their unsigned counterparts) have 8, 16, 32, and 64 bits respectively. The types <span class="token">float</span> and <span class="token">double</span> have 32 and 64 bits respectively. See the section on <a href="#primitive_types">Primitive Types</a> for further details.</p>

<h4 id="diff_no_function_pointers">No function pointers</h4>
<p>Indeed, the Bond language makes no provisions for function pointers.</p>

<h4 id="diff_no_variadic_functions">No variadic functions</h4>
<p>Adding support for variadic functions involves work that has not been tackled. Bond may have variadic functions someday, but for the time being, that work is not planned.</p>

<h4 id="diff_namespaces">Namespaces</h4>
<p>Bond has namespaces that serve the same purpose as C++ namespaces, which is to prevent name collisions. All declarations of the Bond standard library are in the <span class="token">Bond</span> namespace.

<pre class="code">Namespace Foo
{
    const int BAR = 42;
}

// Identifiers within namespaces are qualified with ::
const int BAZ = Foo::BAR;</pre>

<p>See the section on <a href="#namespaces">Namespaces</a> for further details.</p>

<h4 id="diff_member_functions">Structs can have member functions</h4>
<p>Another aspect borrowed from C++ is struct member functions. See the section on <a href="#struct_types">Structure Types</a> for further details.</p>

<h4 id="diff_no_globals">No global or static variables</h4>
<p>Global constants are permitted, however, global variables are not. (TODO: see the documentation on the Virtual Machine Architecture for the justification.)</p>

<pre class="code">const int[2][3] GLOBAL_CONSTANT = {{1, 2, 3}, {4, 5, 6}}; // Permitted
int[2][3] GLOBAL_VARIABLE = {{1, 2, 3}, {4, 5, 6}};       // Error</pre>

<p>There are also no static variables, so all local variables have a lifetime that does not surpass that of the scope in which they are declared.</p>

<h4 id="diff_native_blocks">Native blocks</h4>
<p>Declarations for functions and structs implemented in C++ can be placed in native blocks, allowing those functions to be called and those types to be manipulated from Bond code with full type checking and semantic analysis.See the section on <a href="#native_blocks">Native Blocks</a> for further details.</p>

<h2 id="language_ref">Language Reference</h2>
<h3 id="elements">Basics of Bond</h3>

<h4>Structure of a Program</h4>
<p>For a quick overview of several of the fundamental concepts of Bond, let us take a quick look at the ubiquitous Hello World program. The source code for it follows.</p>

<pre class="lineno">1
2
3
4
5
6
7
8</pre>
<pre class="code">// This is a Hello World program written in Bond.
include &quot;io.bond&quot;;

int main()
{
    Bond::StdOut()-&gt;PrintStr(&quot;Hello World!&quot;);
    return 0;
}</pre>

<p>When this program runs, it prints the following output to the screen.</p>

<pre class="code">Hello World!</pre>

<p>Here is a line-by-line breakdown of the program.</p>

<dl>
<dt>Line 1: <span class="token">// This is a Hello World program written in Bond.</span></dt>
<dd>Two consecutive forward slashes indicate the beginning of  a comment. Comments are useful for documenting code, but do not influence the program. They are ignored by the compiler.</dd>

<dt>Line 2: <span class="token">include &quot;io.bond&quot;;</span></dt>
<dd>An include directive tells the compiler that the programmer wishes to reference code written in another file. In this case, the referenced file is <span class="token">io.bond</span>. The file <span class="token">io.bond</span> is part of the Standard Bond Library and defines input and output operations.</dd>
</dl>

<dt>Line 3: A blank line.</dt>
<dd>Blank lines have no effect on the program, but do help to organize code and improve readability.</dd>

<dt>Line 4: <span class="token">int main()</span></dt>
<dd>This line begins the declaration of a function whose name is <span class="token">main</span>. A function encapsulates the code that performs a specific task or operation. Functions are covered in greater detail in the <a href="#primitive_types">Functions</a> section later.

<p>A function declaration specifies a return type (i.e. what kind of result the function produces; in this case <span class="token">int</span>), a name (<span class="token">main</span>), and a parameter list enclosed in parentheses (i.e. the operands of the operation performed by the function). This example does not require any parameters.</p>

<p>The <span class="token">main</span> function is a special function for standalone Bond programs. It is the entry point of the program (i.e. where execution of the program begins). When Bond is embedded in a larger application written in C++, any function may be an entry point.</p>
</dd>

<dt>Lines 5 and 8: <span class="token">{</span> and <span class="token">}</span></dt>
<dd>A function has an opening brace and a closing brace to enclose its body, the code that performs the function's task.</dd>

<dt>Line 6: <span class="token">Bond::StdOut()-&gt;PrintStr(&quot;Hello World!&quot;);</span></dt>
<dd>This line of code is a statement. Statements perform actions. This particular line of code is quite loaded, since it calls two functions.

<p>The first function is called <span class="token">Bond::StdOut</span> and it is defined in <span class="token">io.bond</span>, which was included on line 2. The function is actually just called <span class="token">StdOut</span> and it is defined in the namespace called <span class="token">Bond</span>. We will see more about namespaces in the <a href="#namespaces">Namespaces</a> section. The pair of parentheses that follow indicate that we are calling the function. The function returns an <span class="token">OutputStream</span>, which allows the program to print some output.</p>

<p>The second function is called <span class="token">PrintStr</span>. The <span class="token">-></span> symbol indicates that the function belongs to the <span class="token">OutputStream</span> returned by the first function. Again the pair of parentheses indicate that we are calling the function. However, this time the parentheses enclose the string <span class="token">&quot;Hello World!&quot;</span>. That string is given to the <span class="token">PrintStr</span> function so that the function may print it to the screen.</p>
</dd>

<dt>Line 7: <span class="token">return 0;</span></dt>
<dd>This line of code is a statement that specifies what value is returned by the main function. As we saw on line 4, the main function returns an <span class="token">int</span>. In Bond, as with other programming languages, such as C and C++, the return value of the <span class="token">main</span> function indicates the exit status of the program. By convention a return value of 0 indicates that the program terminated normally, whereas any other value indicates an application specific error code.</dd>

<h4 id="identifiers">Identifiers</h4>
<p>Identifiers are names for symbols such as variables, functions and types defined in code. Identifiers consist of any sequence of letters, digits and underscores ('_'), with the exception that the first character cannot be a digit. Also, keywords are reserved and cannot be used as identifiers. Identifiers are case sensitive.</p>

<h4 id="keywords">Keywords</h4>
<p>Keywords are reserved by the language and have special meaning for the compiler. The following is a list of all Bond keywords.</p>

<div class="code"><p>bool break case cast char const continue default do double else enum false float for if include int long namespace native null return short sizeof struct switch this true uchar uint ulong ushort void while</p></div>

<h4 id="primitive_types">Primitive Types</h4>
<p>Bond is a statically typed language, so every variable and expression has a type known at compile time. The type of a value describes how much space it occupies in memory, how that memory is interpreted and what operations and range of values are valid. At the core of the type system are the primitive types. Primitive types are predefined in the language and are named by their reserved keyword. The type system is actually much more vast and the remaining types are covered in the <a href="#data_types">Data Types</a> section.</p>

<h5 id="boolean_type">Boolean Type</h5>
<p>There is one type to represent Boolean values named <span class="token">bool</span>. It has two values: <span class="token">true</span> and <span class="token">false</span>. The bool type is implemented in the Bond Runtime Library using the C++ <span class="token">uint8_t</span> type.</p>

<h5 id="integer_types">Integer Types</h5>
<p>The integer data types are used for storing values which are whole numbers. There are several types that vary in size and range of values that they can represent. Note that the <span class="token">char</span> and <span class="token">uchar</span> types are used to store characters.</p>

<p>The following table provides the details for all of the integer types, including the underlying C++ types used to implement them in the Bond Runtime Library.</p>

<table>
<tr>
<th>Type</th>
<th>C++ Type</th>
<th>Storage Size</th>
<th>Value Range</th>
</tr>

<tr>
<td><span class="token">char</span></td>
<td><span class="token">int8_t</span></td>
<td>8 bits</td>
<td>-128 to 127</td>
</tr>

<tr>
<td><span class="token">uchar</span></td>
<td><span class="token">uint8_t</span></td>
<td>8 bits</td>
<td>0 to 256</td>
</tr>

<tr>
<td><span class="token">short</span></td>
<td><span class="token">int16_t</span></td>
<td>16 bits</td>
<td>-32,768 to 32,767</td>
</tr>

<tr>
<td><span class="token">ushort</span></td>
<td><span class="token">uint16_t</span></td>
<td>16 bits</td>
<td>0 to 65,535</td>
</tr>

<tr>
<td><span class="token">int</span></td>
<td><span class="token">int32_t</span></td>
<td>32 bits</td>
<td>-2,147,483,648 to 2,147,483,647</td>
</tr>

<tr>
<td><span class="token">uint</span></td>
<td><span class="token">uint32_t</span></td>
<td>32 bits</td>
<td>0 to 4,294,967,295</td>

<tr>
<td><span class="token">long</span></td>
<td><span class="token">int64_t</span></td>
<td>64 bits</td>
<td>-9,223,372,036,854,775,808 to 9,223,372,036,854,775,807</td>
</tr>

<tr>
<td><span class="token">ulong</span></td>
<td><span class="token">uint64_t</span></td>
<td>64 bits</td>
<td>0 to 18,446,744,073,709,551,615</td>
</tr>
</table>

<h5 id="floating_point_types">Floating-Point Types</h5>
<p>Bond supports two floating-point types which are used for storing values that approximate real numbers: <span class="token">float</span> and <span class="token">double</span>. These two types are implemented in the Bond Runtime Library using the C++ <span class="token">float</span> and <span class="token">double</span> types, which are assumed to conform to the IEEE 754 <a href="https://en.wikipedia.org/wiki/Single-precision_floating-point_format">binary32</a> and <a href="https://en.wikipedia.org/wiki/Double-precision_floating-point_format">binary64</a> formats respectively.</p>

<h4 id="literal_constants">Literal Constants</h4>
Literal constants represent immutable values in source code. They can be booleans, numbers, characters, strings of characters or the null pointer.

<h5 id="bool_constants">Boolean Constants</h5>
<p>The type bool has two values represented by the keywords <span class="token">true</span> and <span class="token">false</span>.</p>

<h5 id="integer_constants">Integer Constants</h5>
<p>Integer constants represent integral values (i.e. whole numbers). They can be expressed in decimal (base 10), octal (base 8) or hexadecimal (base 16).</p>

<p>Hexadecimal integers consist of <span class="token">0x</span> and a sequence of hexadecimal digits which are the digits <span class="token">0</span> through <span class="token">9</span> and the letters <span class="token">a</span> through <span class="token">f</span> and <span class="token">A</span> through <span class="token">F</span>. For example, <span class="token">0x2f</span> represents decimal value 47.</p>

<p>Octal integers consist of <span class="token">0</span> and a sequence of octal digits which are the digits <span class="token">0</span> through <span class="token">7</span>. For example, <span class="token">063</span> represents the decimal value 51.</p>

<p>Decimal integers consist a sequence of the digits <span class="token">0</span> through <span class="token">9</span> and cannot begin with a <span class="token">0</span>.</p>

<p>An optional suffix <span class="token">u</span> or <span class="token">U</span> can be appended to force the value to be of type <span class="token">uint</span> and an optional suffix <span class="token">l</span> or <span class="token">L</span> can be appended to force the value to be of type <span class="token">long</span>. The two can be combined to create values of type <span class="token">ulong</span>. For example, <span class="token">27u</span> is of type <span class="token">uint</span> and <span class="token">27ul</span> is of type <span class="token">ulong</span>.</p>

<h5 id="floating_point_constants">Floating-Point Constants</h5>
<p>Floating-point constants represent an approximation of real numbers. They are composed of an integral part, a decimal point, a fractional part and an exponent part. The integral part or the fractional part may be omitted, but not both and the exponent may always be omitted. The integral and fractional parts consist of a sequence of digits, while the exponent consists of <span class="token">e</span> or <span class="token">E</span> followed by an optional sign and a sequence of digits.</p>

<p>An optional suffix <span class="token">f</span> or <span class="token">F</span> can be appended to force the value to be of type <span class="token">float</span>, otherwise the value will be of type <span class="token">double</span>.</p>

<p>The following are examples of valid floating-point constants.</p>
<pre class="code">3.          // Decimal part only. Without a '.' the value would be an int.
.5          // Fractional part only.
3.14159     // Both decimal and fractional parts.
314159e-5   // Same as above expressed with an exponent.
3.14159f    // This value is of type float.</pre>

<h5 id="character_constants">Character Constants</h5>
<p>Character constants represent values of type char and are typically expressed as a single character between single quotes. For example, <span class="token">'a'</span> represents the letter a.</p>

<p>Some values cannot be expressed with a single character and are expressed as an escape sequence between single quotes. Escape sequences begin with a backslash and are depicted in the table below.</p>

<h5 id="string_literals">String Literals</h5>
<p>String literals represent a sequence of characters of type <span class="token">const char[]</span>. They consist of a sequence of character constants enclosed in double quotes and are implicitly terminated with a null character (<span class="token">\0</span>).</p>

<!--
<h5 id="null_pointer">Null Pointer</h5>
<p>The null pointer, a pointer that points to nothing, is represented by the keyword <span class="token">null</span>. The null pointer does not have a specific type (e.g. <span class="token">void *</span>, <span class="token">char *</span>) and it can be assigned to or compared with any pointer type without a cast.</p> -->

<h4 id="variables">Variables</h4>
<p>A variable is a named storage area for a value of a particular type. A variable can be used to store the result of a computation, and recalling it later. The syntax to declare a variable is a type name followed by a name (an identifier). The following snippet shows the declaration of a variable named <span class="token">x</span> that stores an <span class="token">int</span>.</p>

<pre class="code">int x;</pre>

<p>Several variables of the same type can be declared at once by using a comma separated list of names.</p>

<pre class="code">int x, y, z;</pre>

<p>However, it is often easier to read and understand code that uses separate declarations.</p>

<pre class="code">int x;
int y;
int z;</pre>

<p>A variable can be initialized when it is declared by following its name with an equal sign and an expression that produces the value that is assigned to the variable.</p>

<pre class="code">int x = 7;</pre>

<p>The value of a variable can be accessed by placing its name in an expression.</p>

<pre class="code">int x = 6;
int y = 8;

// Add the value of variables x and y.
int sum = x + y;</pre>

<p>A variable can be assigned a new value over the course of a program's execution by placing it on the left hand side of an equal sign.</p>

<pre class="code">// Initialize x to 0.
int x = 0;

// Add 1 to the current value of x and assign the result to x.
x = x + 1;

// The value of x is now 1.</pre>

<p>A variable declared with the keyword <span class="token">const</span> cannot have its value changed after it has been initialized.</p>

<pre class="code">const double PI = 3.14159;
PI = 4; // Error. Cannot assign a value to a const variable.</pre>

<p>There are at least two benefits to using constant variables. The first is that it enables the compiler to perform optimizations. If a constant variable is initialized with a constant expression that can be evaluated at compile time, writing and reading the variable's value to and from memory becomes a superfluous activity. The compiler can instead substitute the variable's value, which it already knows, directly into the generated code wherever that variable is referenced.</p>

<p>The second benefit to constant variables is that they improve the readability of code. Even if the value of a constant variable is not known at compile time, it provides the reader with a guarantee that there is no code that alters the value of the variable after it has been initialized.</p>

<pre class="code">const int result = CalculateResult();

// Skip many lines of complicated code.

// Without understanding all of the above code, we are certain
// that the value of result has been determined on the first line.
int resultPlusOne = result + 1;</pre>









<h4 id="punctuation">Operators</h4>
<div class="code"><p>+ - * / % ++ -- < <= > >= << >> == != ! && || & | ^ ~ ? -> = <<= >>= += -= *= /= %= &= |= ^= ( ) { } [ ] . ; : :: ,</p></div>

<h3 id="statements">Statements</h3>

<h3 id="functions">Functions</h3>

<h3 id="data_types">Data Types</h3>
<p>Bond is a statically typed language, so every variable and expression has a type known at compile time.</p>

<p>Bond is also intended to be a strongly typed language, however, at the moment it is rather weakly typed. The compiler allows the conversion of any numerical type to any other numerical type without an explicit cast, either through assignment or the usual arithmetic conversions, even if it could result in a loss of data. The compiler also allows the conversion of any pointer type to any other pointer type without an explicit cast. These loopholes in the type checking system are expected to be closed in the future.</p>

<h4 id="enum_types">Enumerated Types</h4>

<h4 id="array_types">Array Types</h4>

<h4 id="struct_types">Structure Types</h4>

<h4 id="pointer_types">Pointer Types</h4>

<h3 id="namespaces">Namespaces</h3>

<h3 id="native_blocks">Native Blocks</h3>

<br>
</div> <!--content-->

</div> <!--page-->
</body>
</html>
