<!DOCTYPE html>
<html>
<head>
<title>Bond Programming Language</title>
<link rel="stylesheet" type="text/css" href="css/bond.css">
</head>

<body>
<div class="page">

<div class="header">
<img class="headlogo" src="img/bond_logo_90x124.png" alt="Bond Logo">
<p class="prodid">Bond</p>
</div>

<ul class="navbar">
<li class="navbutton"><a href="index.html">Home</a></li>
<li class="navbutton"><a href="documentation.html">Documentation</a></li>
<li class="navbutton"><a href="download.html">Download</a></li>
<li class="navbutton"><a href="license.html">License</a></li>
</ul>

<div class="content">

<h2 id="language">The Bond Language</h2>
<p>When Bond was created, the goal was not to invent yet another language; it was more of an endeavour to create a minimalistic runtime environment for a bytecode interpreted language. So, where possible, Bond borrowed its syntax and semantics from C. This document begins by covering some notable differences that exist between Bond and C that exist in the spirit of keeping things clean and simple. Then the document moves on to cover the Bond language in detail.</p>

<ul class="toc">
<li class="toc_h2"><a href="#differences_with_c">Notable Differences With C</a></li>
<li class="toc_h3"><a href="#diff_no_preprocessor">No preprocessor</a></li>
<li class="toc_h3"><a href="#diff_no_headers">No header files or forward declarations</a></li>
<li class="toc_h3"><a href="#diff_include">Include directives</a></li>
<li class="toc_h3"><a href="#diff_ambiguities">Ambiguities in the grammar</a></li>
<li class="toc_h3"><a href="#diff_type_declarations">Type declarations</a></li>
<li class="toc_h3"><a href="#diff_primitive_names">Primitive type names</a></li>
<li class="toc_h3"><a href="#diff_fixed_width">Numeric types have a fixed width</a></li>
<li class="toc_h3"><a href="#diff_no_function_pointers">No function pointers</a></li>
<li class="toc_h3"><a href="#diff_no_variadic_functions">No variadic functions</a></li>
<li class="toc_h3"><a href="#diff_namespaces">Namespaces</a></li>
<li class="toc_h3"><a href="#diff_member_functions">Structs can have member functions</a></li>
<li class="toc_h3"><a href="#diff_no_globals">No global or static variables</a></li>
<li class="toc_h3"><a href="#diff_native_blocks">Native blocks</a></li>
<li class="toc_h2"><a href="#language_ref">Language Reference</a></li>
<li class="toc_h3"><a href="#elements">Basics of Bond</a></li>
<li class="toc_h4"><a href="#None">Structure of a Program</a></li>
<li class="toc_h4"><a href="#identifiers">Identifiers</a></li>
<li class="toc_h4"><a href="#keywords">Keywords</a></li>
<li class="toc_h4"><a href="#primitive_types">Primitive Types</a></li>
<li class="toc_h5"><a href="#boolean_type">Boolean Type</a></li>
<li class="toc_h5"><a href="#integer_types">Integer Types</a></li>
<li class="toc_h5"><a href="#floating_point_types">Floating-Point Types</a></li>
<li class="toc_h4"><a href="#literal_constants">Literal Constants</a></li>
<li class="toc_h5"><a href="#bool_constants">Boolean Constants</a></li>
<li class="toc_h5"><a href="#integer_constants">Integer Constants</a></li>
<li class="toc_h5"><a href="#floating_point_constants">Floating-Point Constants</a></li>
<li class="toc_h5"><a href="#character_constants">Character Constants</a></li>
<li class="toc_h5"><a href="#string_literals">String Literals</a></li>
<li class="toc_h4"><a href="#variables">Variables</a></li>
<li class="toc_h4"><a href="#operators">Operators</a></li>
<li class="toc_h5"><a href="#assignment_operator">Assignment Operator</a></li>
<li class="toc_h5"><a href="#arithmetic_operators">Arithmetic Operators</a></li>
<li class="toc_h5"><a href="#increment_operators">Increment and Decrement Operators</a></li>
<li class="toc_h5"><a href="#relational_operators">Relational and Comparison Operators</a></li>
<li class="toc_h5"><a href="#logical_operators">Logical Operators</a></li>
<li class="toc_h5"><a href="#bitwise_logical_operators">Bitwise Logical Operators</a></li>
<li class="toc_h5"><a href="#bit_shifting_operators">Bit Shifting Operators</a></li>
<li class="toc_h5"><a href="#compound_assignment_operators">Compound Assignment Operators</a></li>
<li class="toc_h5"><a href="#ternary_operator">Ternary Operator</a></li>
<li class="toc_h5"><a href="#type_casting_operator">Type Casting Operator</a></li>
<li class="toc_h5"><a href="#sizeof_operator">sizeof Operator</a></li>
<li class="toc_h5"><a href="#operator_precedence">Operator Precedence</a></li>
<li class="toc_h3"><a href="#statements">Statements</a></li>
<li class="toc_h3"><a href="#functions">Functions</a></li>
<li class="toc_h3"><a href="#data_types">Data Types</a></li>
<li class="toc_h4"><a href="#enum_types">Enumerated Types</a></li>
<li class="toc_h4"><a href="#array_types">Array Types</a></li>
<li class="toc_h4"><a href="#struct_types">Structure Types</a></li>
<li class="toc_h4"><a href="#pointer_types">Pointer Types</a></li>
<li class="toc_h3"><a href="#namespaces">Namespaces</a></li>
<li class="toc_h3"><a href="#native_blocks">Native Blocks</a></li>
</ul>

<h2 id="differences_with_c">Notable Differences With C</h2>

<h4 id="diff_no_preprocessor">No preprocessor</h4>
<p>There is no preprocessor, so there are no macros or other mechanisms to manipulate the source code before it is scanned by the compiler.</p>

<h4 id="diff_no_headers">No header files or forward declarations</h4>
<p>All code is placed in <span class="token">.bond</span> files with no need for separate header files. Header files are not needed since type, function and constant declarations do not need to occur before they are referenced in source code; the compiler will resolve those references during semantic analysis after all files have been parsed. This important difference with C also means that structs do not need to be forward declared and functions do not need separate declarations and definitions.</p>

<h4 id="diff_include">Include directives</h4>
<p>Despite the lack of header files, the Bond language supports include directives so that the compiler may be informed about where referenced code is defined so that it may be scanned and parsed prior to semantic analysis. In contrast to C's include directive, Bond's is a compiler directive, not a preprocessor directive. The text of the included file is not substituted in place into the including file. Instead, the referenced file is added to the list of files to be scanned by the compiler if it is not already in the list. If files are multiply or circularly included, the compiler will only scan the included file once. The syntax is as follows. Note that <span class="token">include</span> is a reserved keyword.</p>

<pre class="code">include &quot;file/to/include.bond&quot;;</pre>

<h4 id="diff_ambiguities">Ambiguities in the grammar</h4>
<p>C's grammar is ambiguous and Bond inherited those ambiguities. Some statements in C can be parsed in more than one way, such as the following:</p>

<pre class="code">A * B;</pre>

<p>This line of code can be parsed as the declarative statement: <span class="token">B</span> is a pointer to type <span class="token">A</span>. Or it can be parsed as the expression statement: the value of variable <span class="token">A</span> times the value of variable <span class="token">B</span>. C compilers resolve the ambiguity using forward declarations and by giving the parser access to the symbol table so that it can look up whether <span class="token">A</span> is a type. This approach introduces a burden on the programmer to add forward declarations to the source code and pushes elements of semantic analysis (i.e. maintenance of the symbol table) into the parser.</p>

<p>Fortunately, such ambiguities result in statements with no effect when parsed as expression statements, so it is not necessary to support such statements. Bond's approach to resolving the ambiguity is to favour parsing statements as declarative statements whenever possible. If it turns out that <span class="token">A</span> is not a type, the semantic analyzer will raise an error to that effect during a later stage of compilation.</p>

<p>In hindsight, it may have been worth considering eliminating such ambiguities by modifying the syntax for declarative statements.</p>

<p>For clarity and to avoid other possible ambiguities, the syntax for casting and the sizeof operator were both slightly modified. The syntax for casting is:</p>

<pre class="code">cast&lt;type&gt;(expression)</pre>

<p>The sizeof operator comes in two forms: one for types and one for expressions:</p>

<pre class="code">sizeof&lt;type&gt;
sizeof expression</pre>

<p>The expression in the second form can optionally be wrapped in parentheses as is the case in C.</p>

<h4 id="diff_type_declarations">Type declarations</h4>
<p>To simplify reading and parsing type declarations, all elements pertaining to type declarations (e.g. type names, <span class="token">[]</span>, <span class="token">*</span>, <span class="token">const</span>) appear prior to variable names. The most obvious effect of this change is with array declarations, but there are some other subtleties as well.</p>

<pre class="code">int[3][5] array; // C equivalent is: int array[3][5];
int[3] a, b;     // Both a and b are of type int[3].
int* a, b;       // Both a and b are of type int*. In C, a is int* and b is int.</pre>

<h4 id="diff_primitive_names">Primitive type names</h4>
<p>All primitive type names consist of a single reserved keyword. Where C has the type <span class="token">unsigned int</span>, Bond has <span class="token">uint</span>.</p>

<h4 id="diff_fixed_width">Numeric types have a fixed width</h4>
<p>The types <span class="token">char</span>, <span class="token">short</span>, <span class="token">int</span> and <span class="token">long</span> (as well as their unsigned counterparts) have 8, 16, 32, and 64 bits respectively. The types <span class="token">float</span> and <span class="token">double</span> have 32 and 64 bits respectively. See the section on <a href="#primitive_types">Primitive Types</a> for further details.</p>

<h4 id="diff_no_function_pointers">No function pointers</h4>
<p>Indeed, the Bond language makes no provisions for function pointers.</p>

<h4 id="diff_no_variadic_functions">No variadic functions</h4>
<p>Adding support for variadic functions involves work that has not been tackled. Bond may have variadic functions someday, but for the time being, that work is not planned.</p>

<h4 id="diff_namespaces">Namespaces</h4>
<p>Bond has namespaces that serve the same purpose as C++ namespaces, which is to prevent name collisions. All declarations of the Bond standard library are in the <span class="token">Bond</span> namespace.

<pre class="code">Namespace Foo
{
    const int BAR = 42;
}

// Identifiers within namespaces are qualified with ::
const int BAZ = Foo::BAR;</pre>

<p>See the section on <a href="#namespaces">Namespaces</a> for further details.</p>

<h4 id="diff_member_functions">Structs can have member functions</h4>
<p>Another aspect borrowed from C++ is struct member functions. See the section on <a href="#struct_types">Structure Types</a> for further details.</p>

<h4 id="diff_no_globals">No global or static variables</h4>
<p>Global constants are permitted, however, global variables are not. (TODO: see the documentation on the Virtual Machine Architecture for the justification.)</p>

<pre class="code">const int[2][3] GLOBAL_CONSTANT = {{1, 2, 3}, {4, 5, 6}}; // Permitted
int[2][3] GLOBAL_VARIABLE = {{1, 2, 3}, {4, 5, 6}};       // Error</pre>

<p>There are also no static variables, so all local variables have a lifetime that does not surpass that of the scope in which they are declared.</p>

<h4 id="diff_native_blocks">Native blocks</h4>
<p>Declarations for functions and structs implemented in C++ can be placed in native blocks, allowing those functions to be called and those types to be manipulated from Bond code with full type checking and semantic analysis.See the section on <a href="#native_blocks">Native Blocks</a> for further details.</p>

<h2 id="language_ref">Language Reference</h2>
<h3 id="elements">Basics of Bond</h3>

<h4>Structure of a Program</h4>
<p>For a quick overview of several of the fundamental concepts of Bond, let us take a quick look at the ubiquitous Hello World program. The source code for it follows.</p>

<pre class="lineno">1
2
3
4
5
6
7
8</pre>
<pre class="code">// This is a Hello World program written in Bond.
include &quot;io.bond&quot;;

int main()
{
    Bond::StdOut()-&gt;PrintStr(&quot;Hello World!&quot;);
    return 0;
}</pre>

<p>When this program runs, it prints the following output to the screen.</p>

<pre class="code">Hello World!</pre>

<p>Here is a line-by-line breakdown of the program.</p>

<dl>
<dt>Line 1: <span class="token">// This is a Hello World program written in Bond.</span></dt>
<dd>Two consecutive forward slashes indicate the beginning of  a comment. Comments are useful for documenting code, but do not influence the program. They are ignored by the compiler.</dd>

<dt>Line 2: <span class="token">include &quot;io.bond&quot;;</span></dt>
<dd>An include directive tells the compiler that the programmer wishes to reference code written in another file. In this case, the referenced file is <span class="token">io.bond</span>. The file <span class="token">io.bond</span> is part of the Standard Bond Library and defines input and output operations.</dd>
</dl>

<dt>Line 3: A blank line.</dt>
<dd>Blank lines have no effect on the program, but do help to organize code and improve readability.</dd>

<dt>Line 4: <span class="token">int main()</span></dt>
<dd>This line begins the declaration of a function whose name is <span class="token">main</span>. A function encapsulates the code that performs a specific task or operation. Functions are covered in greater detail in the <a href="#primitive_types">Functions</a> section later.

<p>A function declaration specifies a return type (i.e. what kind of result the function produces; in this case <span class="token">int</span>), a name (<span class="token">main</span>), and a parameter list enclosed in parentheses (i.e. the operands of the operation performed by the function). This example does not require any parameters.</p>

<p>The <span class="token">main</span> function is a special function for standalone Bond programs. It is the entry point of the program (i.e. where execution of the program begins). When Bond is embedded in a larger application written in C++, any function may be an entry point.</p>
</dd>

<dt>Lines 5 and 8: <span class="token">{</span> and <span class="token">}</span></dt>
<dd>A function has an opening brace and a closing brace to enclose its body, the code that performs the function's task.</dd>

<dt>Line 6: <span class="token">Bond::StdOut()-&gt;PrintStr(&quot;Hello World!&quot;);</span></dt>
<dd>This line of code is a statement. Statements perform actions. This particular line of code is quite loaded, since it calls two functions.

<p>The first function is called <span class="token">Bond::StdOut</span> and it is defined in <span class="token">io.bond</span>, which was included on line 2. The function is actually just called <span class="token">StdOut</span> and it is defined in the namespace called <span class="token">Bond</span>. We will see more about namespaces in the <a href="#namespaces">Namespaces</a> section. The pair of parentheses that follow indicate that we are calling the function. The function returns an <span class="token">OutputStream</span>, which allows the program to print some output.</p>

<p>The second function is called <span class="token">PrintStr</span>. The <span class="token">-></span> symbol indicates that the function belongs to the <span class="token">OutputStream</span> returned by the first function. Again the pair of parentheses indicate that we are calling the function. However, this time the parentheses enclose the string <span class="token">&quot;Hello World!&quot;</span>. That string is given to the <span class="token">PrintStr</span> function so that the function may print it to the screen.</p>
</dd>

<dt>Line 7: <span class="token">return 0;</span></dt>
<dd>This line of code is a statement that specifies what value is returned by the <span class="token">main</span> function. As we saw on line 4, the <span class="token">main</span> function returns an <span class="token">int</span>. In Bond, as with other programming languages, such as C and C++, the return value of the <span class="token">main</span> function indicates the exit status of the program. By convention, a return value of 0 indicates that the program terminated normally, whereas any other value indicates an application specific error code.</dd>

<h4 id="identifiers">Identifiers</h4>
<p>Identifiers are names for symbols such as variables, functions and types defined in code. Identifiers consist of any sequence of letters, digits and underscores ('_'), with the exception that the first character cannot be a digit. Also, keywords are reserved and cannot be used as identifiers. Identifiers are case sensitive.</p>

<h4 id="keywords">Keywords</h4>
<p>Keywords are reserved by the language and have special meaning for the compiler. The following is a list of all Bond keywords.</p>

<div class="code"><p>bool break case cast char const continue default do double else enum false float for if include int long namespace native null return short sizeof struct switch this true uchar uint ulong ushort void while</p></div>

<h4 id="primitive_types">Primitive Types</h4>
<p>Bond is a statically typed language, so every variable and expression has a type known at compile time. The type of a value describes how much space it occupies in memory, how that memory is interpreted and what operations and range of values are valid. At the core of the type system are the primitive types. Primitive types are predefined in the language and are named by their reserved keyword. The type system is actually much more vast and the remaining types are covered in the <a href="#data_types">Data Types</a> section.</p>

<h5 id="boolean_type">Boolean Type</h5>
<p>There is one type to represent Boolean values named <span class="token">bool</span>. It has two values: <span class="token">true</span> and <span class="token">false</span>. The <span class="token">bool</span> type is implemented in the Bond Runtime Library using the C++ <span class="token">uint8_t</span> type.</p>

<h5 id="integer_types">Integer Types</h5>
<p>The integer data types are used for storing values which are whole numbers. There are several types that vary in size and range of values that they can represent. Note that the <span class="token">char</span> and <span class="token">uchar</span> types are used to store characters.</p>

<p>The following table provides the details for all of the integer types, including the underlying C++ types used to implement them in the Bond Runtime Library.</p>

<table>
<tr>
<th>Type</th>
<th>C++ Type</th>
<th>Storage Size</th>
<th>Value Range</th>
</tr>

<tr>
<td><span class="token">char</span></td>
<td><span class="token">int8_t</span></td>
<td>8 bits</td>
<td>-128 to 127</td>
</tr>

<tr>
<td><span class="token">uchar</span></td>
<td><span class="token">uint8_t</span></td>
<td>8 bits</td>
<td>0 to 256</td>
</tr>

<tr>
<td><span class="token">short</span></td>
<td><span class="token">int16_t</span></td>
<td>16 bits</td>
<td>-32,768 to 32,767</td>
</tr>

<tr>
<td><span class="token">ushort</span></td>
<td><span class="token">uint16_t</span></td>
<td>16 bits</td>
<td>0 to 65,535</td>
</tr>

<tr>
<td><span class="token">int</span></td>
<td><span class="token">int32_t</span></td>
<td>32 bits</td>
<td>-2,147,483,648 to 2,147,483,647</td>
</tr>

<tr>
<td><span class="token">uint</span></td>
<td><span class="token">uint32_t</span></td>
<td>32 bits</td>
<td>0 to 4,294,967,295</td>

<tr>
<td><span class="token">long</span></td>
<td><span class="token">int64_t</span></td>
<td>64 bits</td>
<td>-9,223,372,036,854,775,808 to 9,223,372,036,854,775,807</td>
</tr>

<tr>
<td><span class="token">ulong</span></td>
<td><span class="token">uint64_t</span></td>
<td>64 bits</td>
<td>0 to 18,446,744,073,709,551,615</td>
</tr>
</table>

<h5 id="floating_point_types">Floating-Point Types</h5>
<p>Bond supports two floating-point types which are used for storing values that approximate real numbers: <span class="token">float</span> and <span class="token">double</span>. These two types are implemented in the Bond Runtime Library using the C++ <span class="token">float</span> and <span class="token">double</span> types, which are assumed to conform to the IEEE 754 <a href="https://en.wikipedia.org/wiki/Single-precision_floating-point_format">binary32</a> and <a href="https://en.wikipedia.org/wiki/Double-precision_floating-point_format">binary64</a> formats respectively.</p>

<h4 id="literal_constants">Literal Constants</h4>
Literal constants represent immutable values in source code. They can be booleans, numbers, characters, strings of characters or the null pointer.

<h5 id="bool_constants">Boolean Constants</h5>
<p>The type bool has two values represented by the keywords <span class="token">true</span> and <span class="token">false</span>.</p>

<h5 id="integer_constants">Integer Constants</h5>
<p>Integer constants represent integral values (i.e. whole numbers). They can be expressed in decimal (base 10), octal (base 8) or hexadecimal (base 16).</p>

<p>Hexadecimal integers consist of <span class="token">0x</span> and a sequence of hexadecimal digits which are the digits <span class="token">0</span> through <span class="token">9</span> and the letters <span class="token">a</span> through <span class="token">f</span> and <span class="token">A</span> through <span class="token">F</span>. For example, <span class="token">0x2f</span> represents decimal value 47.</p>

<p>Octal integers consist of <span class="token">0</span> and a sequence of octal digits which are the digits <span class="token">0</span> through <span class="token">7</span>. For example, <span class="token">063</span> represents the decimal value 51.</p>

<p>Decimal integers consist a sequence of the digits <span class="token">0</span> through <span class="token">9</span> and cannot begin with a <span class="token">0</span>.</p>

<p>An optional suffix <span class="token">u</span> or <span class="token">U</span> can be appended to force the value to be of type <span class="token">uint</span> and an optional suffix <span class="token">l</span> or <span class="token">L</span> can be appended to force the value to be of type <span class="token">long</span>. The two can be combined to create values of type <span class="token">ulong</span>. For example, <span class="token">27u</span> is of type <span class="token">uint</span> and <span class="token">27ul</span> is of type <span class="token">ulong</span>.</p>

<h5 id="floating_point_constants">Floating-Point Constants</h5>
<p>Floating-point constants represent an approximation of real numbers. They are composed of an integral part, a decimal point, a fractional part and an exponent part. The integral part or the fractional part may be omitted, but not both and the exponent may always be omitted. The integral and fractional parts consist of a sequence of digits, while the exponent consists of <span class="token">e</span> or <span class="token">E</span> followed by an optional sign and a sequence of digits.</p>

<p>An optional suffix <span class="token">f</span> or <span class="token">F</span> can be appended to force the value to be of type <span class="token">float</span>, otherwise the value will be of type <span class="token">double</span>.</p>

<p>The following are examples of valid floating-point constants.</p>
<pre class="code">3.          // Decimal part only. Without a '.' the value would be an int.
.5          // Fractional part only.
3.14159     // Both decimal and fractional parts.
314159e-5   // Same as above expressed with an exponent.
3.14159f    // This value is of type float.</pre>

<h5 id="character_constants">Character Constants</h5>
<p>Character constants represent values of type char and are typically expressed as a single character between single quotes. For example, <span class="token">'a'</span> represents the letter a.</p>

<p>Some values cannot be expressed with a single character and are expressed as an escape sequence between single quotes. Escape sequences begin with a backslash and are depicted in the table below.</p>

<h5 id="string_literals">String Literals</h5>
<p>String literals represent a sequence of characters of type <span class="token">const char[]</span>. They consist of a sequence of character constants enclosed in double quotes and are implicitly terminated with a null character (<span class="token">\0</span>).</p>

<!--
<h5 id="null_pointer">Null Pointer</h5>
<p>The null pointer, a pointer that points to nothing, is represented by the keyword <span class="token">null</span>. The null pointer does not have a specific type (e.g. <span class="token">void *</span>, <span class="token">char *</span>) and it can be assigned to or compared with any pointer type without a cast.</p> -->

<h4 id="variables">Variables</h4>
<p>A variable is a named storage area for a value of a particular type. A variable can be used to store the result of a computation, and recalling it later. The syntax to declare a variable is a type name followed by a name (an identifier). The following snippet shows the declaration of a variable named <span class="token">x</span> that stores an <span class="token">int</span>.</p>

<pre class="code">int x;</pre>

<p>Several variables of the same type can be declared at once by using a comma separated list of names.</p>

<pre class="code">int x, y, z;</pre>

<p>However, it is often easier to read and understand code that uses separate declarations.</p>

<pre class="code">int x;
int y;
int z;</pre>

<p>A variable can be initialized when it is declared by following its name with an equal sign and an expression that produces the value that is assigned to the variable.</p>

<pre class="code">int x = 7;</pre>

<p>The value of a variable can be accessed by placing its name in an expression.</p>

<pre class="code">int x = 6;
int y = 8;

// Add the value of variables x and y.
int sum = x + y;</pre>

<p>A variable can be assigned a new value over the course of a program's execution by placing it on the left hand side of an equal sign.</p>

<pre class="code">// Initialize x to 0.
int x = 0;

// Add 1 to the current value of x and assign the result to x.
x = x + 1;

// The value of x is now 1.</pre>

<p>A variable declared with the keyword <span class="token">const</span> cannot have its value changed after it has been initialized.</p>

<pre class="code">const double PI = 3.14159;
PI = 4; // Error. Cannot assign a value to a const variable.</pre>

<p>There are at least two benefits to using constant variables. The first is that it enables the compiler to perform optimizations. If a constant variable is initialized with a constant expression that can be evaluated at compile time, writing and reading the variable's value to and from memory becomes a superfluous activity. The compiler can instead substitute the variable's value, which it already knows, directly into the generated code wherever that variable is referenced.</p>

<p>The second benefit to constant variables is that they improve the readability of code. Even if the value of a constant variable is not known at compile time, it provides the reader with a guarantee that there is no code that alters the value of the variable after it has been initialized.</p>

<pre class="code">const int result = CalculateResult();

// Skip many lines of complicated code.

// Without understanding all of the above code, we are certain
// that the value of result has been determined on the first line.
int resultPlusOne = result + 1;</pre>

<h4 id="operators">Operators</h4>

<!-- TODO: Mention parentheses to force precedence. -->

<h5 id="assignment_operator">Assignment Operator</h5>

<p>As we have seen in the <a href="#variables">Variables</a> section, the assignment operator, represented by an equal sign =, assigns a value to a variable. Even though the assignment operator is represented by an equal sign, it is not used for determining equality.</p>

<p>The expression producing the value that is assigned is on the right side of the assignment operator, and the variable receiving the value is on the left. In the following example, the value of the variable <span class="token">y</span> is assigned to the variable <span class="token">x</span>.<p>

<pre class="code">x = y;</pre>

<p>As with all other expressions, the assignment expression evaluates to a value, which is the value assigned. The value of the assignment expression can then be used in another expression. This approach should be used carefully, since it can lead to code which is difficult to understand. In the following example, the assignment of the value <span class="token">7</span> to the variable <span class="token">y</span> produces the value <span class="token">7</span>, which is then added to the value <span class="token">8</span> and assigned to the variable <span class="token">x</span>.</p>

<pre class="code">x = 8 + (y = 7); // x is 15 and y is 7.</pre>

<h5 id="arithmetic_operators">Arithmetic Operators</h5>
<p>The five binary arithmetic operators are <span class="token">+</span>, <span class="token">-</span>, <span class="token">*</span>, <span class="token">/</span> and <span class="token">%</span>, and they perform addition, subtraction, multiplication, division and modulo division respectively. The syntax for using these operators is straightforward and resembles the notation for basic arithmetic (i.e. the two operands appear on either side of the operator). The operands can be any expression that evaluates to a numerical type, including constants, variables, other arithmetic expressions, function calls and so forth.</pre>

<pre class="code">double a = 2.0;
double b = a + 1.0;      // Addition: b is 3.0.
double c = b - 7.0;      // Subtraction: c is -4.0.
double d = b * c;        // Multiplication: d is -12.0.
double e = d / a;        // Division: e is -6.0.
int remainder = 23 % 10; // Modulo division: remainder is 3.</pre>

<p>Modulo division, which is applicable only to integers, produces the remainder of a division.</p>

<!-- TODO: usual arithmetic conversions -->

<p>The <span class="token">+</span> and <span class="token">-</span> operators can also be used as unary operators and appear before their lone operand. The <span class="token">-</span> operator negates its operand, meaning that it is equivalent to multiplying the operand by <span class="token">-1</span>. The <span class="token">+</span> operator is equivalent to multiplying its operand by <span class="token">1</span>, which leaves it intact. It is not particularly useful and is only included in the language for completeness.</p>

<pre class="code">double a = 3.0;
double b = -a; // b is -3.0.
double c = -b; // c is 3.0.
double d = +a; // d is 3.0.
double e = +b; // e is -3.0.</pre>

<p>Putting it all together:</p>

<pre class="code">double a = -2.0 - -((3.0 * 12.0) / (3.0 + 6.0)); // a is 2.0.</pre>

<h5 id="increment_operators">Increment and Decrement Operators</h5>
<p>Since adding and subtracting <span class="token">1</span> from variables is such a common thing to do when programming, special shorthand operators exist specifically for that task denoted with <span class="token">++</span> and <span class="token">--</span>. The former adds <span class="token">1</span> to its operand and the latter subtracts <span class="token">1</span>.</p>

<p>The following two lines of code are equivalent methods of adding <span class="token">1</span> to the variable <span class="token">a</span>.</p>

<pre class="code">++a;
a = a + 1;</pre>

<p>Likewise, the following two lines of code are equivalent methods of subtracting <span class="token">1</span> from the variable <span class="token">a</span>.</p>

<pre class="code">--a;
a = a - 1;</pre>

<p>Furthermore, the increment and decrement operators can both be used in prefix or suffix forms. Both forms perform the same operation, however they differ in their order of evaluation. In the prefix form, the addition or subtraction is performed first, then the value of the expression is evaluated. In the suffix form, the value of expression is evaluated first, then the addition or subtraction is performed. The following examples show the difference.</p>

<pre class="code">int a = 7;
int b = ++a;
// a is 8 and b is also 8. a is incremented before its value is captured.

a = 7;
b = a++;
// a is 8, but b is 7. The value of a is captured before it is incremented.</pre>

<h5 id="relational_operators">Relational and Comparison Operators</h5>
<p>The six relational operators are <span class="token">==</span>, <span class="token">!=</span>, <span class="token">&lt;</span>, <span class="token">&gt;</span>, <span class="token">&lt;=</span> and <span class="token">&gt=</span>, and they are used to compare the value of two expressions. The result of a relational operator is a <span class="token">bool</span> (i.e. either the value <span class="token">true</span> or <span class="token">false</span>) indicating whether the comparison was successful.</p>

<p>The <span class="token">==</span> and <span class="token">!=</span> operators test whether two values are equal or not equal respectively.</p>

<pre class="code">int a = 7;
int b = 7;
int c = 9;
a == b;    // Result is true since both operands are 7.
a == c;    // Result is false since both operands are 7.
a != b;    // Result is false since one operand is 7 and one is 9.
a != b;    // Result is true since one operand is 7 and one is 9.</pre>

<p>The <span class="token">&lt;</span>, <span class="token">&gt;</span>, <span class="token">&lt;=</span> and <span class="token">&gt=</span> operators test whether the first operand is less than, greater than, less than or equal to and greater than or equal to the second operator respectively.</p>

<pre class="code">int a = 7;
int b = 7;
int c = 9;
a < b;     // Result is false since 7 is not less than 7.
a < c;     // Result is true since 7 is less than 9.
c < a;     // Result is false since 9 is not less than 7.
a > b;     // Result is false since 7 is not greater than 7.
a > c;     // Result is false since 7 is not greater than 9.
c > a;     // Result is true since 9 is greater than 7.
a <= b;    // Result is true since 7 is equal to 7.
a <= c;    // Result is true since 7 is less than 9.
c <= a;    // Result is false since 9 is not less than or equal to 7.
a >= b;    // Result is true since 7 is equal to 7.
a >= c;    // Result is false since 7 is not greater than or equal to 9.
c >= a;    // Result is true since 9 is greater than 7.</pre>

<h5 id="logical_operators">Logical Operators</h5>
<p>The two binary logical operators <span class="token">&amp;&amp</span> and <span class="token">||</span> are used for combining the truth values of two Boolean expressions.</p>

<p>The conjunction operator <span class="token">&amp;&amp</span> evaluates to <span class="token">true</span> only if its operands are both <span class="token">true</span>, otherwise it evaluates to <span class="token">false</span>. If the first operand is <span class="token">false</span>, the second operand is not evaluated at all, since the expression will evaluate to <span class="token">false</span> regardless of the second operand's value.</p>

<p>The disjunction operator <span class="token">||</span> evaluates to <span class="token">false</span> only if its operands are both <span class="token">false</span>, otherwise it evaluates to <span class="token">true</span>. If the first operand is <span class="token">true</span>, the second operand is not evaluated at all, since the expression will evaluate to <span class="token">true</span> regardless of the second operand's value.</p>

<pre class="code">bool a = true;
bool b = true;
bool c = false;
bool d = false;
a &amp;&amp; b;    // Result is true since both operands are true.
a &amp;&amp; c;    // Result is false since second operand is false.
c &amp;&amp; a;    // Result is false since first operand is false.
c &amp;&amp; d;    // Result is false since both operands are false.
a || b;    // Result is true since both operands are true.
a || c;    // Result is true since first operand is true.
c || a;    // Result is true since second operand is true.
c || d;    // Result is false since both operands are false.</pre>

<p>The third logical operator is the unary not operator <span class="token">!</span>. This operator negates the value of its Boolean operand, such that <span class="token">false</span> becomes <span class="token">true</span> and vice-versa.</p>

<p>We can combine all of the operators that we have learned so far to formulate more complex conditions. The following snippet of code checks whether a variable named <span class="token">value</span> falls in the range [5 - 10] if the range check is enabled. If the range check is not enabled, the condition always succeeds.</p>

<pre class="code">bool conditionValid = !rangeCheckEnabled || ((value >= 5) && (value <= 10));</pre>

<h5 id="bitwise_logical_operators">Bitwise Logical Operators</h5>
<p>There are a handful of operators for directly manipulating the bits of integer values. First are the bitwise logical operators, which are analogous to the Boolean logical operators seen above. Withc each of the binary bitwise logical operators, each bit of the left operand is paired with the corresponding bit of the right operand and the operation is performed between each pair of bits. A bit value of 0 corresponds to a truth value of <span class="token">false</span>, whereas a bit value of 1 corresponds to a truth value of <span class="token">true</span>.</p>

<p>The <span class="token">&amp;</span> operator performs a bitwise conjunction, while the <span class="token">|</span> operator performs a bitwise disjunction. A third operator, <span class="token">^</span>, performs an exclusive disjunction. In the case of the exclusive disjunction operator, the result is <span class="token">true</span> if only one, but not both of the operands are <span class="token">true</span>.</p>

<pre class="code">int a = 12;
int b = 10;
a & b; // Result is  8, since 1100 & 1010 is 1000.
a | b; // Result is 14, since 1100 | 1010 is 1110.
a ^ b; // Result is  6, since 1100 ^ 1010 is 0110.</pre>

<p>The <span class="token">~</span> operator is analogous to the unary Boolean not operator. It flips each bit of its operand such that 0 becomes 1 and 1 becomes 0. Note that all bits including leading zeroes and the sign bit of signed integers are flipped.</p>

<pre class="code">int a = 12;
~a; // Result is -13, since ~1100 is 11111111111111111111111111110011.</pre>

<h5 id="bit_shifting_operators">Bit Shifting Operators</h5>
<p>Another set of operators for manipulating the bits of integers are the bit shifting operators. The left shift operator <span class="token">&lt;&lt;</span> shifts the bits of the left operand to the left. The right operand specifies the number of positions by which the bits are shifted. Bits shifted out of the left side are discarded whereas bits inserted to the right are zero.</p>

<p>Similarly, the <span class="token">&gt;&gt;</span> operator shifts the bits of the left operand to the right by the number of positions specified by the right operand. Bits shifted out of the right side are discarded and bits inserted into the left side follow slightly more complicated rules. Inserted bits are usually zero, however, if the left operand is a signed integer, then the inserted bits are the same as the contents of the leftmost bit (i.e. the sign bit). This behaviour has the interesting property of preserving the sign of the left operand.</p>

<h5 id="compound_assignment_operators">Compound Assignment Operators</h5>

<h5 id="ternary_operator">Ternary Operator</h5>

<h5 id="type_casting_operator">Type Casting Operator</h5>

<h5 id="sizeof_operator">sizeof Operator</h5>

<h5 id="operator_precedence">Operator Precedence</h5>

<h3 id="statements">Statements</h3>

<h3 id="functions">Functions</h3>

<h3 id="data_types">Data Types</h3>
<p>Bond is a statically typed language, so every variable and expression has a type known at compile time.</p>

<p>Bond is also intended to be a strongly typed language, however, at the moment it is rather weakly typed. The compiler allows the conversion of any numerical type to any other numerical type without an explicit cast, either through assignment or the usual arithmetic conversions, even if it could result in a loss of data. The compiler also allows the conversion of any pointer type to any other pointer type without an explicit cast. These loopholes in the type checking system are expected to be closed in the future.</p>

<p>We have already seen the primitive types for storing simple values, however, Bond's type system supports several others.</p>

<h4 id="enum_types">Enumerated Types</h4>
<p>An enumeration is a set of named integer constants. Values of an enumeration are represented using the type <span class="token">int</span>, and behave as the <span class="token">int</span> type in every respect (e.g. array indexing, arithmetic operations, relational operations, etc.).</p>

<p>An enumeration is declared using the <span class="token">enum</span> keyword, followed by an identifier to name the type, an open brace, an enumerator list, a closing brace and a semicolon.</p>

<pre class="code">enum AnimalSound
{
    Moo,        // Value is 0 since this is the first enumerator.
    Oink,       // Value is 1 since Moo + 1 = 1.
    Baa = 42,   // Value is explicitly specified as 42.
    Quack,      // Value is 43 since Baa + 1 = 43.
    Meow = -1,  // Values can be negative.
    Woof        // Values can be duplicated. This one is also 0.
};</pre>

<p>The enumerator list consists of a comma separated list of enumerators. A comma following the last enumerator is allowed, but not required.</p>

<p>An enumerator can be a single identifier. In that case its value is 0 if it is the first enumerator, or it takes the value of the previous enumerator + 1. Alternatively an enumerator can be an identifier followed by an equal sign and a constant expression. In that case it takes on the value of the constant expression.</p>

<p>We can declare and initialize a variable of an enumerated type as we would a variable of any other type. In this case, we declare the type as <span class="token">AnimalSound</span>, and use the name of any one of the enumerators in the initializer. We could also have used any other expression, such as a function call, that resolves to an <span class="token">AnimalSound</span>.</p>

<pre class="code">AnimalSound sound = Moo;</pre>

<h4 id="array_types">Array Types</h4>

<h4 id="struct_types">Structure Types</h4>

<h4 id="pointer_types">Pointer Types</h4>

<h3 id="namespaces">Namespaces</h3>

<h3 id="native_blocks">Native Blocks</h3>

<br>
</div> <!--content-->

</div> <!--page-->
</body>
</html>
