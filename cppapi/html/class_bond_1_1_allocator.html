<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Bond: Bond::Allocator Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Bond<span id="projectnumber">&#160;0.9</span>
   </div>
   <div id="projectbrief">C++ Bond Runtime Library API Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('class_bond_1_1_allocator.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_bond_1_1_allocator-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Bond::Allocator Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span><div class="ingroups"><a class="el" href="group__systems.html">Systems</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Abstract base class defining the interface through which all components of <a class="el" href="namespace_bond.html">Bond</a> perform memory and object allocations.  
 <a href="class_bond_1_1_allocator.html#details">More...</a></p>

<p><code>#include &lt;bond/systems/allocator.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Bond::Allocator:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_bond_1_1_allocator.png" usemap="#Bond::Allocator_map" alt=""/>
  <map id="Bond::Allocator_map" name="Bond::Allocator_map">
<area href="class_bond_1_1_default_allocator.html" title="A simple implementation of Allocator that allocates and frees memory using the new and delete operato..." alt="Bond::DefaultAllocator" shape="rect" coords="0,56,138,80"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_bond_1_1_allocator_1_1_aligned_deallocator.html">AlignedDeallocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A custom unique_ptr deleter that deallocates aligned memory by calling <a class="el" href="class_bond_1_1_allocator.html#a6dca1d0e262561c46aef5715d538b191" title="Frees the aligned memory pointed to by the given pointer. The memory must have been allocated by this...">Allocator::FreeAligned</a>, rather than the delete operator. The memory is only freed; no object destruction is performed.  <a href="struct_bond_1_1_allocator_1_1_aligned_deallocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bond_1_1_allocator_1_1_aligned_handle.html">AlignedHandle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An owning memory handle that derives from unique_ptr that deallocates memory using an <a class="el" href="struct_bond_1_1_allocator_1_1_aligned_deallocator.html" title="A custom unique_ptr deleter that deallocates aligned memory by calling Allocator::FreeAligned,...">AlignedDeallocator</a> rather than std::default_delete when it goes out of scope.  <a href="class_bond_1_1_allocator_1_1_aligned_handle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_bond_1_1_allocator_1_1_aligned_object_deallocator.html">AlignedObjectDeallocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A custom unique_ptr deleter that destroys an aligned object by calling its destructor then freeing its memory by calling <a class="el" href="class_bond_1_1_allocator.html#a6dca1d0e262561c46aef5715d538b191" title="Frees the aligned memory pointed to by the given pointer. The memory must have been allocated by this...">Allocator::FreeAligned</a> rather than the delete operator.  <a href="struct_bond_1_1_allocator_1_1_aligned_object_deallocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bond_1_1_allocator_1_1_aligned_object_handle.html">AlignedObjectHandle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An owning object handle that derives from unique_ptr that destroys an aligned object using an <a class="el" href="struct_bond_1_1_allocator_1_1_aligned_object_deallocator.html" title="A custom unique_ptr deleter that destroys an aligned object by calling its destructor then freeing it...">AlignedObjectDeallocator</a> rather than std::default_delete when it goes out of scope.  <a href="class_bond_1_1_allocator_1_1_aligned_object_handle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_bond_1_1_allocator_1_1_deallocator.html">Deallocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A custom unique_ptr deleter that deallocates memory by calling <a class="el" href="class_bond_1_1_allocator.html#af126cf26d4c816747f4171957878415c" title="Frees the memory pointed to by the given pointer. The memory must have been allocated by this allocat...">Allocator::Free</a> rather than the delete operator. The memory is only freed; no object destruction is performed.  <a href="struct_bond_1_1_allocator_1_1_deallocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bond_1_1_allocator_1_1_handle.html">Handle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An owning memory handle that derives from unique_ptr that deallocates memory using a <a class="el" href="struct_bond_1_1_allocator_1_1_deallocator.html" title="A custom unique_ptr deleter that deallocates memory by calling Allocator::Free rather than the delete...">Deallocator</a> rather than std::default_delete when it goes out of scope.  <a href="class_bond_1_1_allocator_1_1_handle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_bond_1_1_allocator_1_1_object_deallocator.html">ObjectDeallocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A custom unique_ptr deleter that destroys an object by calling its destructor then freeing its memory by calling <a class="el" href="class_bond_1_1_allocator.html#af126cf26d4c816747f4171957878415c" title="Frees the memory pointed to by the given pointer. The memory must have been allocated by this allocat...">Allocator::Free</a> rather than the delete operator.  <a href="struct_bond_1_1_allocator_1_1_object_deallocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bond_1_1_allocator_1_1_object_handle.html">ObjectHandle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An owning object handle that derives from unique_ptr that destroys an object using an <a class="el" href="struct_bond_1_1_allocator_1_1_object_deallocator.html" title="A custom unique_ptr deleter that destroys an object by calling its destructor then freeing its memory...">ObjectDeallocator</a> rather than std::default_delete when it goes out of scope.  <a href="class_bond_1_1_allocator_1_1_object_handle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a93fde48af1a8eedf3eb59ec6cbba4a94"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bond_1_1_allocator.html#a93fde48af1a8eedf3eb59ec6cbba4a94">~Allocator</a> ()</td></tr>
<tr class="separator:a93fde48af1a8eedf3eb59ec6cbba4a94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a209afb39837588ac6bb50d812d4b5ef0"><td class="memItemLeft" align="right" valign="top">virtual void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bond_1_1_allocator.html#a209afb39837588ac6bb50d812d4b5ef0">Allocate</a> (size_t size)=0</td></tr>
<tr class="memdesc:a209afb39837588ac6bb50d812d4b5ef0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates and returns a pointer to a block of uninitialized memory of the given size.  <a href="class_bond_1_1_allocator.html#a209afb39837588ac6bb50d812d4b5ef0">More...</a><br /></td></tr>
<tr class="separator:a209afb39837588ac6bb50d812d4b5ef0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f3a272ae19a0e9fa50413fbe1a6f32f"><td class="memItemLeft" align="right" valign="top">virtual void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bond_1_1_allocator.html#a5f3a272ae19a0e9fa50413fbe1a6f32f">AllocateAligned</a> (size_t size, size_t align)=0</td></tr>
<tr class="memdesc:a5f3a272ae19a0e9fa50413fbe1a6f32f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates and returns a pointer to a block of uninitialized memory with the given size and alignment.  <a href="class_bond_1_1_allocator.html#a5f3a272ae19a0e9fa50413fbe1a6f32f">More...</a><br /></td></tr>
<tr class="separator:a5f3a272ae19a0e9fa50413fbe1a6f32f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af126cf26d4c816747f4171957878415c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bond_1_1_allocator.html#af126cf26d4c816747f4171957878415c">Free</a> (void *buffer)=0</td></tr>
<tr class="memdesc:af126cf26d4c816747f4171957878415c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the memory pointed to by the given pointer. The memory must have been allocated by this allocator's Allocate method.  <a href="class_bond_1_1_allocator.html#af126cf26d4c816747f4171957878415c">More...</a><br /></td></tr>
<tr class="separator:af126cf26d4c816747f4171957878415c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dca1d0e262561c46aef5715d538b191"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bond_1_1_allocator.html#a6dca1d0e262561c46aef5715d538b191">FreeAligned</a> (void *buffer)=0</td></tr>
<tr class="memdesc:a6dca1d0e262561c46aef5715d538b191"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the aligned memory pointed to by the given pointer. The memory must have been allocated by this allocator's Allocate method.  <a href="class_bond_1_1_allocator.html#a6dca1d0e262561c46aef5715d538b191">More...</a><br /></td></tr>
<tr class="separator:a6dca1d0e262561c46aef5715d538b191"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afac9f8f25601d36f7832c57c1509cbf3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bond_1_1_allocator.html#afac9f8f25601d36f7832c57c1509cbf3">Free</a> (const void *buffer)</td></tr>
<tr class="memdesc:afac9f8f25601d36f7832c57c1509cbf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls the non-const form of Free after casting away the constness of the given pointer.  <a href="class_bond_1_1_allocator.html#afac9f8f25601d36f7832c57c1509cbf3">More...</a><br /></td></tr>
<tr class="separator:afac9f8f25601d36f7832c57c1509cbf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0074ece5a6c1030276b83645df27d8dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bond_1_1_allocator.html#a0074ece5a6c1030276b83645df27d8dc">FreeAligned</a> (const void *buffer)</td></tr>
<tr class="memdesc:a0074ece5a6c1030276b83645df27d8dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls the non-const form of FreeAligned after casting away the constness of the given pointer.  <a href="class_bond_1_1_allocator.html#a0074ece5a6c1030276b83645df27d8dc">More...</a><br /></td></tr>
<tr class="separator:a0074ece5a6c1030276b83645df27d8dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6fc41e19d69ca0e452baca6cc3ea6ef"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae6fc41e19d69ca0e452baca6cc3ea6ef"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_bond_1_1_allocator.html#ae6fc41e19d69ca0e452baca6cc3ea6ef">Alloc</a> ()</td></tr>
<tr class="memdesc:ae6fc41e19d69ca0e452baca6cc3ea6ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates and returns a pointer to a block of uninitialized memory large enough to accomodate an object of type T.  <a href="class_bond_1_1_allocator.html#ae6fc41e19d69ca0e452baca6cc3ea6ef">More...</a><br /></td></tr>
<tr class="separator:ae6fc41e19d69ca0e452baca6cc3ea6ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a701c14ddd9f69ee62c1cd04bae97f060"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a701c14ddd9f69ee62c1cd04bae97f060"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_bond_1_1_allocator.html#a701c14ddd9f69ee62c1cd04bae97f060">Alloc</a> (size_t numElements)</td></tr>
<tr class="memdesc:a701c14ddd9f69ee62c1cd04bae97f060"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates and returns a pointer to a block of uninitialized memory large enough to accomodate an array of objects of type T.  <a href="class_bond_1_1_allocator.html#a701c14ddd9f69ee62c1cd04bae97f060">More...</a><br /></td></tr>
<tr class="separator:a701c14ddd9f69ee62c1cd04bae97f060"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d30e7bd9fb008abc4805827414949f4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1d30e7bd9fb008abc4805827414949f4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_bond_1_1_allocator_1_1_handle.html">Handle</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_bond_1_1_allocator.html#a1d30e7bd9fb008abc4805827414949f4">AllocOwned</a> ()</td></tr>
<tr class="memdesc:a1d30e7bd9fb008abc4805827414949f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates and returns an owning handle to a block of uninitialized memory large enough to accomodate an object of type T.  <a href="class_bond_1_1_allocator.html#a1d30e7bd9fb008abc4805827414949f4">More...</a><br /></td></tr>
<tr class="separator:a1d30e7bd9fb008abc4805827414949f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a558295be4f904ee9dd3c5703925cd712"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a558295be4f904ee9dd3c5703925cd712"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_bond_1_1_allocator_1_1_handle.html">Handle</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_bond_1_1_allocator.html#a558295be4f904ee9dd3c5703925cd712">AllocOwned</a> (size_t numElements)</td></tr>
<tr class="memdesc:a558295be4f904ee9dd3c5703925cd712"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates and returns an owning handle to a block of uninitialized memory large enough to accomodate an array of objects of type T.  <a href="class_bond_1_1_allocator.html#a558295be4f904ee9dd3c5703925cd712">More...</a><br /></td></tr>
<tr class="separator:a558295be4f904ee9dd3c5703925cd712"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74713893e2b4c9179e3fe68018d75d52"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a74713893e2b4c9179e3fe68018d75d52"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_bond_1_1_allocator.html#a74713893e2b4c9179e3fe68018d75d52">AllocAligned</a> (size_t align)</td></tr>
<tr class="memdesc:a74713893e2b4c9179e3fe68018d75d52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates and returns a pointer to a block of uninitialized aligned memory large enough to accomodate an object of type T.  <a href="class_bond_1_1_allocator.html#a74713893e2b4c9179e3fe68018d75d52">More...</a><br /></td></tr>
<tr class="separator:a74713893e2b4c9179e3fe68018d75d52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dd901bc6741244d438651a64cb1dc66"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4dd901bc6741244d438651a64cb1dc66"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_bond_1_1_allocator.html#a4dd901bc6741244d438651a64cb1dc66">AllocAligned</a> (size_t numElements, size_t align)</td></tr>
<tr class="memdesc:a4dd901bc6741244d438651a64cb1dc66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates and returns a pointer to a block of uninitialized aligned memory large enough to accomodate an array of objects of type T.  <a href="class_bond_1_1_allocator.html#a4dd901bc6741244d438651a64cb1dc66">More...</a><br /></td></tr>
<tr class="separator:a4dd901bc6741244d438651a64cb1dc66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaafa1426bf06776391ff70c8f599ad65"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aaafa1426bf06776391ff70c8f599ad65"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_bond_1_1_allocator_1_1_aligned_handle.html">AlignedHandle</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_bond_1_1_allocator.html#aaafa1426bf06776391ff70c8f599ad65">AllocOwnedAligned</a> (size_t align)</td></tr>
<tr class="memdesc:aaafa1426bf06776391ff70c8f599ad65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates and returns an owning handle to a block of uninitialized aligned memory large enough to accomodate an object of type T.  <a href="class_bond_1_1_allocator.html#aaafa1426bf06776391ff70c8f599ad65">More...</a><br /></td></tr>
<tr class="separator:aaafa1426bf06776391ff70c8f599ad65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a779a15020490be161441761ded7e93ac"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a779a15020490be161441761ded7e93ac"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_bond_1_1_allocator_1_1_aligned_handle.html">AlignedHandle</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_bond_1_1_allocator.html#a779a15020490be161441761ded7e93ac">AllocOwnedAligned</a> (size_t numElements, size_t align)</td></tr>
<tr class="memdesc:a779a15020490be161441761ded7e93ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates and returns an owning handle to a block of uninitialized aligned memory large enough to accomodate an array of objects of type T.  <a href="class_bond_1_1_allocator.html#a779a15020490be161441761ded7e93ac">More...</a><br /></td></tr>
<tr class="separator:a779a15020490be161441761ded7e93ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af846e3c12d4f9cf60333a0f32a4e584a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:af846e3c12d4f9cf60333a0f32a4e584a"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_bond_1_1_allocator.html#af846e3c12d4f9cf60333a0f32a4e584a">AllocObject</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:af846e3c12d4f9cf60333a0f32a4e584a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates, constructs and returns a pointer to an instance of type T.  <a href="class_bond_1_1_allocator.html#af846e3c12d4f9cf60333a0f32a4e584a">More...</a><br /></td></tr>
<tr class="separator:af846e3c12d4f9cf60333a0f32a4e584a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6a98aaf45d08baa55cba0491ec240b1"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:ab6a98aaf45d08baa55cba0491ec240b1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_bond_1_1_allocator_1_1_object_handle.html">ObjectHandle</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_bond_1_1_allocator.html#ab6a98aaf45d08baa55cba0491ec240b1">AllocOwnedObject</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ab6a98aaf45d08baa55cba0491ec240b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates, constructs and returns an owning handle to an instance of type T.  <a href="class_bond_1_1_allocator.html#ab6a98aaf45d08baa55cba0491ec240b1">More...</a><br /></td></tr>
<tr class="separator:ab6a98aaf45d08baa55cba0491ec240b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4aa73020ae4590802f7722f5e90267b"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:ad4aa73020ae4590802f7722f5e90267b"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_bond_1_1_allocator.html#ad4aa73020ae4590802f7722f5e90267b">AllocAlignedObject</a> (size_t align, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ad4aa73020ae4590802f7722f5e90267b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates, constructs and returns a pointer to an aligned instance of type T.  <a href="class_bond_1_1_allocator.html#ad4aa73020ae4590802f7722f5e90267b">More...</a><br /></td></tr>
<tr class="separator:ad4aa73020ae4590802f7722f5e90267b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5f92e77e7ffb5c7ccda7975c7343f28"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:ae5f92e77e7ffb5c7ccda7975c7343f28"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_bond_1_1_allocator_1_1_aligned_object_handle.html">AlignedObjectHandle</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_bond_1_1_allocator.html#ae5f92e77e7ffb5c7ccda7975c7343f28">AllocOwnedAlignedObject</a> (size_t align, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ae5f92e77e7ffb5c7ccda7975c7343f28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates, constructs and returns an owning handle to an aligned instance of type T.  <a href="class_bond_1_1_allocator.html#ae5f92e77e7ffb5c7ccda7975c7343f28">More...</a><br /></td></tr>
<tr class="separator:ae5f92e77e7ffb5c7ccda7975c7343f28"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Abstract base class defining the interface through which all components of <a class="el" href="namespace_bond.html">Bond</a> perform memory and object allocations. </p>
<p >The <a class="el" href="class_bond_1_1_allocator.html" title="Abstract base class defining the interface through which all components of Bond perform memory and ob...">Allocator</a> provides a variety of methods to allocate memory and to allocate and construct objects, all of which can either be unaligned or aligned. Additionally, it provides methods to destroy objects and free memory, as well as handles that derive from the standard C++ unique_ptr to ensure that resources are released reliably.</p>
<p >Concrete derived classes need to provide implementations for the <a class="el" href="class_bond_1_1_allocator.html#a209afb39837588ac6bb50d812d4b5ef0" title="Allocates and returns a pointer to a block of uninitialized memory of the given size.">Allocator::Allocate</a>, <a class="el" href="class_bond_1_1_allocator.html#a5f3a272ae19a0e9fa50413fbe1a6f32f" title="Allocates and returns a pointer to a block of uninitialized memory with the given size and alignment.">Allocator::AllocateAligned</a>, <a class="el" href="class_bond_1_1_allocator.html#af126cf26d4c816747f4171957878415c" title="Frees the memory pointed to by the given pointer. The memory must have been allocated by this allocat...">Allocator::Free</a> and <a class="el" href="class_bond_1_1_allocator.html#a6dca1d0e262561c46aef5715d538b191" title="Frees the aligned memory pointed to by the given pointer. The memory must have been allocated by this...">Allocator::FreeAligned</a> methods. All other functionality provided by this class is built on top of those four methods. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a93fde48af1a8eedf3eb59ec6cbba4a94" name="a93fde48af1a8eedf3eb59ec6cbba4a94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93fde48af1a8eedf3eb59ec6cbba4a94">&#9670;&#160;</a></span>~Allocator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Bond::Allocator::~Allocator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ae6fc41e19d69ca0e452baca6cc3ea6ef" name="ae6fc41e19d69ca0e452baca6cc3ea6ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6fc41e19d69ca0e452baca6cc3ea6ef">&#9670;&#160;</a></span>Alloc() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T * Bond::Allocator::Alloc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocates and returns a pointer to a block of uninitialized memory large enough to accomodate an object of type T. </p>

</div>
</div>
<a id="a701c14ddd9f69ee62c1cd04bae97f060" name="a701c14ddd9f69ee62c1cd04bae97f060"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a701c14ddd9f69ee62c1cd04bae97f060">&#9670;&#160;</a></span>Alloc() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T * Bond::Allocator::Alloc </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocates and returns a pointer to a block of uninitialized memory large enough to accomodate an array of objects of type T. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numElements</td><td>The number of elements in the allocated array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a74713893e2b4c9179e3fe68018d75d52" name="a74713893e2b4c9179e3fe68018d75d52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74713893e2b4c9179e3fe68018d75d52">&#9670;&#160;</a></span>AllocAligned() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T * Bond::Allocator::AllocAligned </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>align</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocates and returns a pointer to a block of uninitialized aligned memory large enough to accomodate an object of type T. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">align</td><td>The alignment requirements for the allocated memory. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4dd901bc6741244d438651a64cb1dc66" name="a4dd901bc6741244d438651a64cb1dc66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dd901bc6741244d438651a64cb1dc66">&#9670;&#160;</a></span>AllocAligned() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T * Bond::Allocator::AllocAligned </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>align</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocates and returns a pointer to a block of uninitialized aligned memory large enough to accomodate an array of objects of type T. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numElements</td><td>The number of elements in the allocated array. </td></tr>
    <tr><td class="paramname">align</td><td>The alignment requirements for the allocated memory. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad4aa73020ae4590802f7722f5e90267b" name="ad4aa73020ae4590802f7722f5e90267b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4aa73020ae4590802f7722f5e90267b">&#9670;&#160;</a></span>AllocAlignedObject()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T * Bond::Allocator::AllocAlignedObject </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>align</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocates, constructs and returns a pointer to an aligned instance of type T. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">align</td><td>The alignment requirements for the allocated memory. </td></tr>
    <tr><td class="paramname">args</td><td>A list of arguments forwarded to the constructor of the instance of type T. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a209afb39837588ac6bb50d812d4b5ef0" name="a209afb39837588ac6bb50d812d4b5ef0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a209afb39837588ac6bb50d812d4b5ef0">&#9670;&#160;</a></span>Allocate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void * Bond::Allocator::Allocate </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocates and returns a pointer to a block of uninitialized memory of the given size. </p>

<p>Implemented in <a class="el" href="class_bond_1_1_default_allocator.html#a9e584ff66eb9fad00bdc755a15fca9cf">Bond::DefaultAllocator</a>.</p>

</div>
</div>
<a id="a5f3a272ae19a0e9fa50413fbe1a6f32f" name="a5f3a272ae19a0e9fa50413fbe1a6f32f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f3a272ae19a0e9fa50413fbe1a6f32f">&#9670;&#160;</a></span>AllocateAligned()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void * Bond::Allocator::AllocateAligned </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>align</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocates and returns a pointer to a block of uninitialized memory with the given size and alignment. </p>

<p>Implemented in <a class="el" href="class_bond_1_1_default_allocator.html#a32281af782a1063647f84c9d7ff86b72">Bond::DefaultAllocator</a>.</p>

</div>
</div>
<a id="af846e3c12d4f9cf60333a0f32a4e584a" name="af846e3c12d4f9cf60333a0f32a4e584a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af846e3c12d4f9cf60333a0f32a4e584a">&#9670;&#160;</a></span>AllocObject()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T * Bond::Allocator::AllocObject </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocates, constructs and returns a pointer to an instance of type T. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>A list of arguments forwarded to the constructor of the instance of type T. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1d30e7bd9fb008abc4805827414949f4" name="a1d30e7bd9fb008abc4805827414949f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d30e7bd9fb008abc4805827414949f4">&#9670;&#160;</a></span>AllocOwned() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bond_1_1_allocator_1_1_handle.html">Handle</a>&lt; T &gt; Bond::Allocator::AllocOwned </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocates and returns an owning handle to a block of uninitialized memory large enough to accomodate an object of type T. </p>

</div>
</div>
<a id="a558295be4f904ee9dd3c5703925cd712" name="a558295be4f904ee9dd3c5703925cd712"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a558295be4f904ee9dd3c5703925cd712">&#9670;&#160;</a></span>AllocOwned() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bond_1_1_allocator_1_1_handle.html">Handle</a>&lt; T &gt; Bond::Allocator::AllocOwned </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocates and returns an owning handle to a block of uninitialized memory large enough to accomodate an array of objects of type T. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numElements</td><td>The number of elements in the allocated array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaafa1426bf06776391ff70c8f599ad65" name="aaafa1426bf06776391ff70c8f599ad65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaafa1426bf06776391ff70c8f599ad65">&#9670;&#160;</a></span>AllocOwnedAligned() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bond_1_1_allocator_1_1_aligned_handle.html">AlignedHandle</a>&lt; T &gt; Bond::Allocator::AllocOwnedAligned </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>align</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocates and returns an owning handle to a block of uninitialized aligned memory large enough to accomodate an object of type T. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">align</td><td>The alignment requirements for the allocated memory. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a779a15020490be161441761ded7e93ac" name="a779a15020490be161441761ded7e93ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a779a15020490be161441761ded7e93ac">&#9670;&#160;</a></span>AllocOwnedAligned() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bond_1_1_allocator_1_1_aligned_handle.html">AlignedHandle</a>&lt; T &gt; Bond::Allocator::AllocOwnedAligned </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>align</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocates and returns an owning handle to a block of uninitialized aligned memory large enough to accomodate an array of objects of type T. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numElements</td><td>The number of elements in the allocated array. </td></tr>
    <tr><td class="paramname">align</td><td>The alignment requirements for the allocated memory. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae5f92e77e7ffb5c7ccda7975c7343f28" name="ae5f92e77e7ffb5c7ccda7975c7343f28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5f92e77e7ffb5c7ccda7975c7343f28">&#9670;&#160;</a></span>AllocOwnedAlignedObject()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bond_1_1_allocator_1_1_aligned_object_handle.html">AlignedObjectHandle</a>&lt; T &gt; Bond::Allocator::AllocOwnedAlignedObject </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>align</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocates, constructs and returns an owning handle to an aligned instance of type T. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">align</td><td>The alignment requirements for the allocated memory. </td></tr>
    <tr><td class="paramname">args</td><td>A list of arguments forwarded to the constructor of the instance of type T. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab6a98aaf45d08baa55cba0491ec240b1" name="ab6a98aaf45d08baa55cba0491ec240b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6a98aaf45d08baa55cba0491ec240b1">&#9670;&#160;</a></span>AllocOwnedObject()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bond_1_1_allocator_1_1_object_handle.html">ObjectHandle</a>&lt; T &gt; Bond::Allocator::AllocOwnedObject </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocates, constructs and returns an owning handle to an instance of type T. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>A list of arguments forwarded to the constructor of the instance of type T. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afac9f8f25601d36f7832c57c1509cbf3" name="afac9f8f25601d36f7832c57c1509cbf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afac9f8f25601d36f7832c57c1509cbf3">&#9670;&#160;</a></span>Free() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Bond::Allocator::Free </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calls the non-const form of Free after casting away the constness of the given pointer. </p>

</div>
</div>
<a id="af126cf26d4c816747f4171957878415c" name="af126cf26d4c816747f4171957878415c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af126cf26d4c816747f4171957878415c">&#9670;&#160;</a></span>Free() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Bond::Allocator::Free </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Frees the memory pointed to by the given pointer. The memory must have been allocated by this allocator's Allocate method. </p>

<p>Implemented in <a class="el" href="class_bond_1_1_default_allocator.html#a76c6205b27523ee05eb5a3824d1d9e01">Bond::DefaultAllocator</a>.</p>

</div>
</div>
<a id="a0074ece5a6c1030276b83645df27d8dc" name="a0074ece5a6c1030276b83645df27d8dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0074ece5a6c1030276b83645df27d8dc">&#9670;&#160;</a></span>FreeAligned() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Bond::Allocator::FreeAligned </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calls the non-const form of FreeAligned after casting away the constness of the given pointer. </p>

</div>
</div>
<a id="a6dca1d0e262561c46aef5715d538b191" name="a6dca1d0e262561c46aef5715d538b191"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dca1d0e262561c46aef5715d538b191">&#9670;&#160;</a></span>FreeAligned() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Bond::Allocator::FreeAligned </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Frees the aligned memory pointed to by the given pointer. The memory must have been allocated by this allocator's Allocate method. </p>

<p>Implemented in <a class="el" href="class_bond_1_1_default_allocator.html#aff539565827a26b13ab7e7ed5923941a">Bond::DefaultAllocator</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/bond/systems/allocator.h</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->

<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_bond.html">Bond</a></li><li class="navelem"><a class="el" href="class_bond_1_1_allocator.html">Allocator</a></li>
    <li class="footer"></li>
  </ul>
</div>
</body>
</html>
